# Info
[31778 PPC 만들기](https://boj.kr/31778)

## 💡 풀이 방법 요약
뭔가 문자열로 다루기 싫어서 `P`는 `1`로, `C`는 `0`으로 입력받았다.

부분 배열의 특성 상 `110`을 최대한 많이 만드려면 `1`은 배열의 왼쪽에, `0`은 배열의 오른쪽에 많이 위치할수록 항상 좋다 -> 그리디.

그럼 각 `0`과 `1` 이 위치한 인덱스를 미리 구해 뒀다가 각 시점에서
- 가장 왼쪽에 있는 `0`
- 가장 오른 쪽에 있는 `1`
을 swap 하면 될 것이다.

문제 특성 상 인덱스 저장소를 관리하기 위해 heap을 사용하면 좋을 것 같았다.

루프 안에서 heap을 사용하여 현재시점에서 swap 할 위치를 찾고 swap 하는데, `K` 번 수행하지 않았더라도 `111..000` 형태의 최적 배열이 도출된다면 거기서 멈춰야 한다.  
-> 가장 작은 `0`의 인덱스가 배열 전체 `1`의 개수와 같은지 확인하면 된다.

이후 주어진 `K` 조건 하에서 만들 수 있는 최적 배열이 도출되었을 것이다.  
부분 배열의 개수를 구하기 위해 루프를 돌면서 `0`이 나올 때 마다 자신보다 앞에 있는 `1`의 개수를 구하고, `acc1Count * (acc1Count-1) // 2` 를 `result`에 누적해 준다.

자신보다 앞에 있는 `1`의 개수는 누적합을 활용하여 미리 구해 두면 쉽게 풀 수 있다.

## 👀 실패 이유
`heapq`에 넣을 때 max Heap으로 사용하려면 음수로 바꿔서 넣어 줘야 하는데, 일부 삽입 로직에서 빼먹었다.

## 🙂 마무리
여러 알고리즘 섞어서 써야 하는 꽤 신선한 문제
