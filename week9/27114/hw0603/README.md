# Info
[27114 조교의 맹연습](https://www.acmicpc.net/problem/27114)

## 💡 풀이 방법 요약
원래 방향으로 돌아와야 한다 -> 동작의 순서와는 무관하게 동작`조합` 처럼 생각할 수 있다.  
`좌 우 뒤` 를 여러 번 조합하여 원래 방향을 보게 하려면 다음과 같이 6가지의 경우밖에 생기지 않는다.
- 좌 우
- 뒤 뒤
- 좌 좌 뒤
- 우 우 뒤
- 좌 좌 좌 좌
- 우 우 우 우

각 경우에 대해 차감되는 체력과 추가되는 시도 횟수를 별도로 저장해 둔다.  
이후 `dp[i] = 체력을 i만큼 사용했을 때 **처음 바라보던 방향을 바라보는** 최소 동작 횟수` 로 정의하면 `dp[energy] = min(dp[energy-e]+data[e] for e in data.keys())` 가 성립한다.

dp 테이블을 채우는 루프 종료 후 `dp[K]`가 `INF` 가 아니라면 dp값을, `INF` 라면 `-1`을 출력하면 정답.

## 👀 실패 이유
`data` 정의 시 키가 중복되면 값이 덮어씌워지는 것을 생각을 못 했었다.
```python
data = {
    A+B: 2,  # 좌 우
    C+C: 2,  # 뒤 뒤
    A+A+C: 3,  # 좌 좌 뒤
    B+B+C: 3,  # 우 우 뒤
    A+A+A+A: 4,  # 좌 좌 좌 좌
    B+B+B+B: 4,  # 우 우 우 우
} 
```
위와 같이 정의 시 추가되는 동작 횟수가 더 작은 경우가 큰 경우에 의해 덮어씌워질 수 있으므로 동작 횟수의 최솟값을 제대로 구할 수 없게 된다.

## 🙂 마무리
분류에 배낭 문제도 있던데 냅색 풀이가 바로 딱 떠오르지는 않는 듯.
