# Info
[27313 효율적인 애니메이션 감상](https://www.acmicpc.net/problem/27313)

## 💡 풀이 방법 요약
`K` 개씩 그룹 짓는 것의 효과 -> 그룹 내에서 제일 큰 놈이 대푯값이 되고 나머지는 무시 가능  
`M` 보다 큰 애니는 애초에 시청이 불가능하므로 미리 전처리.

결과적으로, `애니메이션의 개수`를 늘리는 것이 목표이므로 최대한 동시에 시청하도록 해야 함  
-> 그룹 내에서는 최대한 비슷한 값끼리 모여 있는 것이 유리함 -> **정렬 사용의 힌트**

동시 시청하는 애니메이션을 `buffer`(덱) 에 유지한다고 하면,  
동시 시청 제한값이 `2`라 오름차순 정렬된 `a b` 가 현재 동시 시청으로 선택됐다고 하자.  
이때 `c(>b)` 를 시청하고 싶다면 시청 그룹을 두 그룹으로 분리해야 한다.  
이때 첫 번째 그룹의 시청이 끝나야 다음 그룹을 시청할 수 있으므로 가장 상영시간이 작은 `a`를 분리하는 것이 유리할 것이다. (`a | b c`)  
그리고 그 경우 `c`의 시청을 완료한 시각은 `a+c`가 된다. 이전 그룹의 대표값이 다음 그룹에 추가되는 애니메이션의 시청 종료시간에 영향을 미치므로, 큐에는 각 경우의 시청 종료 시간을 기준으로 정보를 저장하도록 하자.

`d(>c)`를 시청하고 싶다면 동일한 원리로 `b`를 앞 그룹으로 보내야 하고, `d`의 시청 종료 시각은 `b+d`가 된다. (`a b | d c`). 이 경우 큐에 저장된 값은 `[a+c, b+d]`가 될 것이다.

조금 더 일반화 해 보면, 매 경우 현재 큐에서 제일 작은(`idx=0`) 원소가 앞 그룹으로 보내지고, 그 원소는 앞 그룹에서 대표값이 됨을 알 수 있다.

따라서 `현재 조사중인 애니의 러닝타임(ani) + buffer[0] <= M` 이라면 `M` 시간제한 이내에 현재 조사중인 애니를 시청할 수 있다는 의미가 된다.  

오름차순 정렬된 애니의 러닝타임 정보를 순차탐색하며 `buffer`를 계속 업데이트하며 현재 조사중인 애니가 `M` 시간제한 이내에 시청될 수 없을 때 까지 루핑하다가, 조건을 벗어나기 전까지 조사한 애니의 개수를 출력하면 정답.

## 🙂 마무리
문제를 보자 마자 `정렬+그리디`의 감이 왔지만.. 정확히 왜 되는지는 아직 와닿지 않는다...
