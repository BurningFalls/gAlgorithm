# Info
[Link](https://boj.kr/32069)
## 💡 풀이 방법 요약
되게 맛있는 문제였음. 머리 쓰는 맛이 있었다 ㅋㅋ

### 풀이

어두운 정도가 0인 위치 찾고 총 개수가 K 미만이면 다음으로

어두운 정도가 1인 위치 찾고 총 개수가 K 미만이면 다음으로 ...

단, 각 단계에서 이미 이전 단계에서 포함된 위치는 제외해야 함! 또한, 위치가 음수거나 L 을 넘어가는 경우는 제외해야 함!

각 가로등을 기준으로 어두운 정도가 i 인 위치를 찾는 것은 O(1)임! 따라서 각 단계를 구하는 작업은 O(n)

최악의 경우를 생각해도 될 거 같았음.

### 생각의 흐름

L 이 짱 크기 때문에, 무조건 K 개의 작은 위치들만 어두운 값을 계산하고 출력해야 한다.

만약, N 이 1이라면, 그 위치에서만 생각하면 되므로 0 1 1 2 2 3 3 ... 이런 수열을 k 번째까지 출력하면 된다.

Ai + (0 ~ k/2) 까지만 그 값을 계산하고 최소값이 그 값이 되도록 갱신하면 우선 O(NK) 로 계산을 할 수 있다.

계산 범위를 더 줄여야 한다. 특정 가로등에 대해 특정 위치의 어두운 정도를 계산할 때, 만약 이미 최소 값인게 있다면, 더이상 그 가로등은 의미가 없다. 그런데, 이 특성을 사용해도 두 가로등 사이의 거리가 충분히 멀면 의미가 없다.

작은걸 출력해야 하니까, PQ 로 작은 것을 먼저 출력하게 하면 되려나?

아니 생각해 보니까, 0인 값은 N개 있을 수 있다. 2 이상인 값은 최대 2 * N 개 있을 수 있다.

결국 각 가로등에 대해 정도가 1인 위치를 반환하게 하고 2인 위치를 반환하게 하고.. 반복하다가 그 개수가 K를 넘기면 종료하고 출력 시작하면 되겠네!

각 가로등에 대해 정도가 T 인 위치를 반환하는 것은 O(1) 이니까 각 레벨의 어두운 정도를 반환하는것은 O(n)!!

처음에는 이전 레벨에 방문한 것을 후처리 하다가, 전처리 해도 되겠다 생각해서 전처리 하니까 통과. 집합 연산의 비용이 O(k) 인데, 매번 더해져서 부담이 된 것 같음.


## 👀 실패 이유
이전 단계를 제외하는 것을 집합 연산을 했어서 시간 초과 난 듯. O(K)가 매 단계에 추가되서 그런가봐

## 🙂 마무리
