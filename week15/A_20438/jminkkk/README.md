# Info
[Link](https://boj.kr/20438)
## 💡 풀이 방법 요약
1. 출석 여부를 나타내는 boolean 값 선언
2. 졸고 있는 학생의 번호를 따로 저장 O(1)
3. 출석 코드를 보낼 학생의 수 입력 받고 그 배수인 아이들을 모두 true O(Q * N)
   + 이때 졸고 있는 학생 번호에 포함되어 있다면 continue; O(Q * K)
4. 구간을 순회하며 번호 ++ O(m * n)

250_000_000

----
0. 출석 여부를 나타내는 boolean 값 선언
1. 졸고 있는 학생의 번호를 따로 저장
2. 출석 코드를 보낼 학생의 수 입력 받아 저장 -> 이때 졸고 있는 학생에 포함되어 있다면 저장 X
3. 확인하려는 구간에 대해 체크 (배열 선언)
   + 번호가 이미 true 라면 continue
   + 번호가 출석 코드 학생의 배수라면 true
   + 번호가 졸고 있는 학생의 번호의 배수라면 ++
   + 졸고 있는 학생의 번호의 배수가 아니여도 출석  ++

---

0. 출석 여부를 나타내는 boolean 값 선언
1. 졸고 있는 학생의 번호를 따로 저장
2. 출석 코드를 보낼 학생의 수 입력 받아 저장 -> 이때 졸고 있는 학생에 포함되어 있다면 저장 X
3. 3 ~ n + 2까지 순회
  + 번호가 이미 true 라면 continue
  + 번호가 출석 코드 학생의 배수라면 true
4. 구간을 입력받고 번호가 false ++

---

다 시간 초과 날 것 같아서 분류 봄

구간합으로 다시 생각해본 풀이

1. 졸고 있는 학생의 번호를 따로 저장
2. 출석 코드를 보낼 학생(attendance에)의 수 입력 받아 저장
   + 이때 만약 i가 자고 있다면 continue
   + 아니면 3 ~ n + 2 안의 i의 배수들을 자고 있지 않다면 attendance에 추가적으로 저장
4. 3 ~ n + 2 까지 순회하면서 누적합 구함

## 👀 실패 이유

a ~ b 구간 구하려면 sum[b] - sum[a - 1] 이여야하는데 sum[b] - sum[a]로 구함

## 🙂 마무리

누적합이 뭔가 떠올리기 어려운 것 같다 

팁 주세요 ~
