# Info
[15926 현욱은 괄호왕이야!!](https://boj.kr/15926)
## 💡 풀이 방법 요약

### 첫 번째 풀이 - `15926_fail.py`
일반적인 괄호쌍 검사 로직과 유사하게 `(` 문자일 경우 스택에 `push()`, `)` 문자가 오면 `pop()` 하며 진행한다.  
단, '문자열의 길이'가 중요한 문제이므로 **스택에는 괄호 문자가 아닌 인덱스 값을 저장한다.**

이때, 올바른 괄호 문자열이 정상적으로 끝나고 새로운 문자열이 시작되는 경우, 새로 시작된 문자열이 올바른 괄호 문자열일 경우에는 앞의 길이를 합산해 주어야 한다.  
- 정상 종료됐을때 올바른 괄호 문자열의 길이를 `buffer에` 저장해 두고, 나중에 꺼내 쓰자!
- 그렇다면 `buffer` 역시 스택 형태로 관리되어야 할 것이다.
- 언제 꺼내 쓸 수 있는지도 기록해 두어야 한다.
  - `(currentPairLenght, availableIdx)` 형태의 튜플을 저장해 두고, `buffer[-1]`의 `availableIdx가` 이후 `stack.pop()` 한 값이 `avalialbleIdx`와 동일한 경우에만 이전에 저장된 `currentPairLenght`를 합산하여 계산한다.
  - `availableIdx` 는 `i+1` 이다. 정상 종료된 이후 바로 다음 문자가 스택에서 정상적으로 `pop()` 되어야 이어지는 문자열 역시 올바른 괄호 문자열이기 때문.


### 두 번째 풀이
반례 찾으려고 구글링했다가 블로그에서 약 스포를 당했는데, 훨씬 깔끔한 것 같아서 해당 풀이로 풀어 봤다.

스택의 맨 밑에는 (유효한 괄호 문자열이 시작되는 위치 - 1)이 있도록 유지한다. 따라서 `stack` 의 초깃값은 `[-1]` 이다.  
- `(` 문자가 나오는 경우
  - `stack.append(idx)`
- `)` 문자가 나오는 경우
  - `stack.pop()` 을 하는데, 다음과 같이 분기한다.
    1. 스택이 비어 있는 경우
       - 유효하지 않은 괄호 문자열이므로 현재 위치를 스택에 넣는다.
    2. 스택이 비어 있지 않은 경우 
       - 유효한 괄호 문자열이므로, 현재 길이인 `(idx - stack[-1])` 을 이전 최댓값과 대소비교하여 최댓값을 갱신해 준다.


## 👀 실패 이유
`buffer`에서 이전 기록을 조회하여 길이를 합산한 이후, 합산된 튜플은 `pop()` 했어야 하는데 이를 누락했다.  
`availableIdx` 검사는 항상 `buffer[-1]`을 기준으로 하므로, 한 번 합산된 이후에는 합산되어야 할 것이 제대로 합산되지 않았던 것

반례 찾느라 한시간 이상 삽질했는데 폭포가 찾아줬다. 그는 신인가?

```text
8
()(()())

was: 6
ans: 8
```

## 🙂 마무리
풀어봤던 괄호 검사류 문제들 중에는 제일 까다로웠던 문제였습니다..
