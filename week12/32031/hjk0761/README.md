# Info
[석고 모형 만들기](https://boj.kr/32031)

## 💡 풀이 방법 요약

문제를 처음 읽었을 때 머리속에서 그림을 떠올리기 힘들었습니다.

하나의 칸이 정육면체이기 때문에 뚫리고 남은 부분은 항상 하나 이상의 모서리를 포함하고, 이는 남은 조각이 모서리에 종속적이라는 것을 알려줍니다.

따라서 뚫리고 남은 부분을 모서리로 단순하게 생각해 볼 수 있습니다.

`O`의 형태(회전축이 바닥에 수직)로 뚫린 칸은 정육면체의 아랫면와 윗면을 이어주는 모서리들로 생각할 수 있고,

`H`의 형태(회전축이 가로)로 뚫린 칸은, 왼쪽면과 오른쪽면을 이어주는 모서리들로,

`I`의 형태(회전축이 세로)로 뚫린 칸은 앞면과 뒷면을 이어주는 모서리들로 생각할 수 있습니다.

따라서 각 칸의 꼭짓점을 노드로 생각하고 모서리를 그래프라고 생각한다면,

(r+1)*(c+1) 개의 노드와 인접한 노드끼리 모두 연결된 단순한 그래프를 순회하면서 연결된 그래프 들의 갯수를 구하는 문제로 단순화 할 수 있습니다.

추가적으로 `O` 형태로 뚫린 칸을 계산하는 부분은 원래 2 * (r+1) + (c+1) 개의 노드를 가지는 그래프로 보고 위아래 연결도 확인했었는데,

메모리 초과의 원인을 못찾아 위아래로 연결되면 한 덩어리, 아니면 두 덩어리가 생기는 것에 착안하여 connected 를 도입한 것입니다.

## 👀 실패 이유

인접 행렬을 사용해서 메모리 초과가 났습니다.

각 칸은 최대 상하좌우 네 개의 칸 밖에 연결될 수 없기에 공간 낭비가 어마어마했습니다.

인접 리스트를 이용해 훨씬 짧게 연결된 칸들만 순회할 수 있었습니다.

## 🙂 마무리

처음에 bfs 대신 union-find 를 사용해서 그룹화된 갯수를 세려고 했는데, union-find 의 시간 복잡도 때문에 시간 초과가 날 것 같아 안해봤습니다.

근데 풀고나서 아루가 알려주길 union-find 가 훨씬 빨랐다고 알려줬습니다.