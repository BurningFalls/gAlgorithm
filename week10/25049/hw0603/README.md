# Info
[25049 뮤직 플레이리스트](https://www.acmicpc.net/problem/25049)

## 💡 풀이 방법 요약
문제을 잘 읽어 보면 `(플레이리스트를 다 들었을 때 얻을 수 있는 만족도 + 최대 2번의 돌아가기로 얻을 수 있는 최대 만족도)` 의 최댓값을 구하는 문제이다.

플레이리스트는 고정되어 있으므로 플레이리스트가 정의되는 순간 해당 리스트를 전부 들었을 때 얻는 만족도 역시 정의된다.  
따라서 `리스트 내에서 겹치지 않는 2개의 구간합 쌍의 원소 합`을 구하는 문제로 볼 수 있다.

구간합을 겹치지 않게 하기 위해서 임의의 기준점 `p`를 잡고, `p`의 좌우에서 각각 최대 구간합을 구한 후 두 구간합의 합을 구할 수 있을 것이다.  
위와 같은 과정을 `(N+1)`개의 모든 `p`에 대해 시뮬레이션하고, 최댓값을 구하면 정답을 구할 수 있다.

하지만 구간합을 구하는 데 `O(N)`의 비용이 들고, 이를 `N+1` 번 반복한다면 `O(N^2)`으로 TLE를 맞을 확률이 높다.  
중복 계산을 피하기 위해 `L->R` 방향으로의 구간합과 `R->L` 방향의 구간합을 미리 다 구해 두고, 각 뱡향의 구간합에 대하여
- `0 ~ p` 범위를 사용할 수 있을 때 구간합의 최댓값 (`L -> R` 구간합의 경우)
- `N-1 ~ p` 범위를 사용할 수 있을 때 구간합의 최댓값 (`R -> L` 구간합의 경우)

위 계산값을 각각 미리 구해 둔다.  
이 과정을 진행하고 나면 임의의 `p` 를 결정했을 때 좌우 구간에서의 구간합 최댓값을 상수 시간에 참조할 수 있게 되고, 결과적으로 `O(N)` 으로 문제를 해결할 수 있다.

`p == 0 or p == N` 인 경우는 전체를 한 번 다시 듣겠다는 의미이므로, 길이가 0인 한쪽 구간에 대해서는 추가 점수를 `0`점으로 계산해 줘야 하고,  
아예 다시 듣기를 하지 않을 수도 있으므로 좌우 부분합의 합계가 0보다 작을 경우에는 이를 합산하면 안 된다.

![image](https://github.com/hw0603/gAlgorithm/assets/31981462/f50c2ec9-7cd4-4b80-96be-b5879f7a0df9)


## 👀 실패 이유
플레이리스트를 한 번도 rewind 하지 않는 경우가 최대 만족도를 줄 수 있는 경우가 있으므로 `result`의 하한선은 `0`점이 되어야 한다.  
이 조건을 빼먹어서 WA.

## 🙂 마무리
어렵네요... DP일거라고는 생각했지만 다른 알고리즘이 다 아닌 것 같아서 소거법으로 DP임을 알고 들어갔던 문제.  
두 부분합이 겹치지 않음을 처리하는 방법을 떠올리는 것과, 매 구분값을 시뮬레이션할 때 중복된 계산을 막는 것이 포인트인데 두 가지 다 한 번에 떠올리기가 쉽지 않았다.  

모 크루가 난이도 기여를 골4로 마킹했길래 바로 골3 줬다ㅎㅎ;
