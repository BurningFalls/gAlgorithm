# Info
[뮤직 플레이리스트](https://www.acmicpc.net/problem/25049)

## 💡 풀이 방법 요약
특정 번째 곡에서 뒤로 돌아갈 수 있는 노래와 바로 다음 곡을 인접 리스트 형태로 표현 가능 => 그래프

곡의 선호도는 그래프의 각 노드의 값. 음수가 될 수 있음. => 특수한 그래프 알고리즘 필요

==> 곡의 개수가 많으므로 브루트포스 그래프 탐색 불가능

i 번째 위치에서 맨 처음 위치로 돌아가서 다시 듣는 경우 = > dp[i] = dp[i-1] + p[i] ~ p[n];

i 번째 위치에서 j ( j < i) 번째 위치로 돌아가서 다시 듣는 경우 => dp[i][j] = dp[i-1][j] + p[i] ~ p[n];

i 번째 위치에서 j 번째 위치로 돌아가서 다시 듣는 경우 => dp[i][j] = dp[i-1][j-1] - p[j] + p[i] ~ p[n];

여러번 돌아갈 수 있는건 어떻게 하지?

같은 노래를 세 번 이상 듣게 되는 경우는 없도록 => k 번째에서 앞으로 건너뛰었다면, 그 다음 건너뛸 수 있는 위치는 k+2 부터다.

max(sum(p), dp[i][j] + max(0, dp[i+2][i+1], dp[i+3][i+2], dp[i+3][i+1], ....))

구간합???

임의의 겹치지 않는 두 구간의 합의 최대값 + 전체 합 = 답

어떤 기준 값에서 왼쪽의 구간 합 중 최대값과 오른쪽 구간합 중 최대값을 더하고, 모든 값에 대해 이 작업을 수행?

어떤 기준 값에서 왼쪽의 구간 합 중 최대값과 오른쪽 구간합 중 최대값 => O(n)에 해야 한다.
## 👀 실패 이유

## 🙂 마무리

