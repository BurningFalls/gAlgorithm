# Info
[11918 정전](https://boj.kr/11918)

## 💡 풀이 방법 요약
수 범위를 보아 하니 위치마나 하나씩 탐색할 수는 없고 가로등의 위치만 탐색하는데, 위치가 작은 것 부터 그리디하게 탐색해야 할 것 같았다 -> 정렬  

정전이니 비상용이니 말을 어렵게 써놔서 한참 헷갈렸는데, 그냥 가로등을 두 그룹으로 나누고, `그룹1`만 켰을 때랑 `그룹2`만 켰을 때 최대한 겹치는 구간이 많도록 하는 문제로 생각할 수 있다. +) 겹치지 않고 혼자 독립적으로 있는 가로등은 풀이에 영향을 미치지 않는다.

결국 여러 가로등이 중첩되어 있을 때, 중첩되는 길이를 구하는 문제이다.  

그럼 독립적으로 존재하는 가로등들을 모두 전처리로 걸러낸 다음에, 중첩되는 가로등을 쭉 탐색하면서 `set` 같은 걸로 중첩 위치의 개수를 구하면 되지 않을까?  
-> 생각해 보니 `L`의 상한이 10억이었다.  
-> 그럼 결국 `start ~ end` 로 범위 탐색 하라는 소리다.

가로등의 영향 범위 (`L`)이 모두 같으므로, `cur`를 기준으로 `cur+L` 과 `next-L`의 대소관계가 어긋나 있다면 해당 가로등 두 개는 중첩이다.  
간단히 생각하면 중첩 위치의 상한은 `cur+L`이 될 것이고, 하한은 `next-L`이 될 것이다.  
그런데 정말 하한이 `next-L` 인가? 만약 `prev`가 `cur`과 꽤 가까이 있어 `next-L` 보다 `prev+L`이 더 커지면 하한은 `prev+L`로 잡아야 한다.  
즉, `max(next-L, prev+L)` 이 하한이 된다.

정리하면 `cur`과 중첩되는 구간이 있을 때, 이번 조사에서 중첩으로 마킹하고 넘어갈 범위는 `[max(next-L, prev+L), cur+L]`인 것.

그럼 구현을 어떻게 할까? `itertools.pairwise()`가 떠오른다. `(prev, cur, next)`를 한 튜플로 묶어서 순회하면 딱 깔끔할 것 같다.  
그런데 알고 보니 `pairwise()`는 3개의 원소를 묶는 것을 지원하지 않는다.  
그럼..어쩔 수 없다. `enumerate()`로 감싼 다음에 `pos[idx-1]`을 `prev`로 정의하고 구현하자.  
그런데 문제가 있다. 파이썬에서는 `idx`가 음수라도 인덱싱이 되기 때문에 `idx==0`일 때 논리에 오류가 생긴다. -> 그럼 `idx > 0` 일 때만 `prev`를 정의하고, 이외의 경우에는 `max()` 연산에 영향을 미치지 않도록 음의 무한대로 초기화하자.


![image](https://github.com/user-attachments/assets/257c221f-ae56-4bcc-80fb-95db3c66bec2)


## 🙂 마무리
진짜 어려웠다;;
처음에는 최적이 되는 비상용 가로등의 위치를 구하고, 밝기를 계산하려고 했었어서 훨씬 어렵게 느껴진듯

처음에 예제가 불친절하다 싶었는데 엄청 친절한 예제였다. 웬만한 케이스들이 다 들어 있더라..
