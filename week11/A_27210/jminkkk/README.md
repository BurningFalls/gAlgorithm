# Info
[신을 모시는 사당](https://www.acmicpc.net/problem/27210)

## 💡 풀이 방법 요약
### 첫 시도
- dp[i][j] = i번째 인덱스부터 금칠을 시작하여 j번째 불상까지의 최대값
- dp[i][j] = Math.max(dp[i][j - 1], sum + 1)

### 두번째 시도
- 금칠 시작 방향이 달라지는 인덱스(index[])를 기록
  - 해당 인덱스에서 이전 인덱스를 뺀 차이(gap[])에 대한 배열 구함
  - sum[]
  - dp[i] = Math.max(dp[i - 1], gap) 
- 변경되는 구간이 더 작다면 채택
  - 1 2 2 1 1 1 2 1 1
    - index[] -> 1 3 6 7
    - gap[] -> 1 2 3 1 (홀수 인덱스 +, 짝수 인덱스 -)
    - gap[] -> 1 -2 3 -1 (홀수 인덱스 +, 짝수 인덱스 -)
    - sum[] -> 1 -1 2 1
  - 1 1 1 2 1 2 2 1 1 1 2 1 1
sum이 -되는 순간 버리고 시작

### 3번째 시도
그리디? 마냥 앞에서부터 차이를 계산 

---

1 ~ n
- 1부터 시작하는 누접합 vs 최대 저장
- 2부터 시작하는 누적합 vs 최대 저장
- ...
- n부터 시작하는 누적합 vs 최대 저장


## 👀 실패 이유
- 시간초과 ~ 되겠냐고 ~ 100_000_000

## 🙂 마무리

